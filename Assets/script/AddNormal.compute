// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


StructuredBuffer<uint> src_instances;
StructuredBuffer<int> src_indices;
StructuredBuffer<float4> src_base_vertices;
StructuredBuffer<float4> src_grid_positions;
StructuredBuffer<float3> src_tri_normals;

StructuredBuffer<int3> src_next_gridids;
RWStructuredBuffer<float3> dst_normals;


const element_block_size = 32 * 32 * 32;
int element_bases[] =
{
				element_block_size * 0,
	element_block_size * 2,	element_block_size * 2,
				element_block_size * 0,
	element_block_size * 1,	element_block_size * 1,
	element_block_size * 1,	element_block_size * 1,
				element_block_size * 0,
	element_block_size * 2,	element_block_size * 2,
				element_block_size * 0,
}

int3 element_spans =
{
				int3(32 ^ 0, 32 ^ 1, 32 ^ 2),
	int3(32 ^ 2, 32 ^ 0, 32 ^ 1), int3(32 ^ 2, 32 ^ 0, 32 ^ 1),
				int3(32 ^ 0, 32 ^ 1, 32 ^ 2),
	int3(32 ^ 1, 32 ^ 2, 32 ^ 0), int3(32 ^ 1, 32 ^ 2, 32 ^ 0),
	int3(32 ^ 1, 32 ^ 2, 32 ^ 0), int3(32 ^ 1, 32 ^ 2, 32 ^ 0),
				int3(32 ^ 0, 32 ^ 1, 32 ^ 2),
	int3(32 ^ 2, 32 ^ 0, 32 ^ 1), int3(32 ^ 2, 32 ^ 0, 32 ^ 1),
				int3(32 ^ 0, 32 ^ 1, 32 ^ 2),


}

int3 vtx_offsets =
{
		int3(0,0,0),
	int3(0,0,0), int3(1,0,0),
		int3(0,0,1),
	int3(0,0,0), int3(1,0,0),
	int3(0,0,1), int3(1,0,1),
		int3(0,1,0),
	int3(0,1,0), int3(1,1,0),
		int3(0,1,1),
}



[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

	uint cube_instance = src_instances[id.x];
	int isrcvtx = getivtx(cube_instatnce);

	int3 cubepos = getpos(cube_instance) + vtx_offsets[isrcvtx];
	int3 innerpos = cubepos & 0x1f;
	int3 outerpos = cubepos >> 5;

	int3 dstspan = element_spans[isrcvtx];

	const int grid_spn = 32 * 32 * 32 * 3;
	int target_grid = lerp(gridid, dot(next_gridid[gridid], outerpos), any(outerpos));
	int base_element = target_gridid * grid_span + element_bases[isrcvtx];

	int idstvtx = base_element + dot(innerpos, dstspan);

}

int3 getpos(uint cube_instance)
{

}

int getivtx(uint cube_instance)
{

}

